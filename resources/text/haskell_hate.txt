RT @sw17ch: @Functionalworks I love this as an accidentally great into to Haskell: http://t.co/AY9cLcFOGR
Monads are the heart and soul of Haskell, and to beginners monads look like scary mathematical blobs, even to those of us with a degree in mathematics. But this book shows through example after example that monads are an imperative programmer's best friend. Monads turn out to be warm fuzzy things that let you reason procedurally in a functional world. For those who know a conventional language, this book will make you fall in love with Haskell.
Our main difficulty at the moment is getting an incremental type checking &amp; inference system working correctly and quickly.<br/><br/>Lamdu's master branch has a slightly buggy system.  new_infer_integration branch has a new system written from scratch that has no known bugs, but is much slower in important scenarios, and has a bit less functionality.  Both don't yet support sum types &amp; pattern-matching.<br/><br/>This has been more difficult to implement than we anticipated. Why use our own type system, and not GHC's, Idris's, Agda's or Ermine's?<br/><br/>Basically we wanted the following set of features:<br/><br/> * As simple a type system as possible.  i.e: we'd prefer a DT system to GHC's many DT-approximating extensions.<br/><br/> * Explicit type variables (lambdas and applications) that the UI hides. It means the type system is simpler and less magical.<br/><br/> * Row types and structural records. We use records extensively, in lieu of currying, to allow keyword arguments. Partial application is made concise and easy to read/write by hiding ETA expanded forms in the UI. We thus want a good record system.<br/><br/> * Polymorphic variants. We want to be able to have precise types everywhere. We think having structural records alongside anonymous sum types (with named constructors) for subexpressions will make it easier to have intermediate precise subexpression types. In Haskell, for example, one is unlikely to define a one-off record/sum type just for some intermediate expressions. Thus, Haskell programs are more likely to use ugly Either/(,) compositions and/or partiality for those cases.<br/><br/> * The type system needs to be able to resume inference after filling of some holes. i.e: Type-check expression with holes, then try various resumption values in the hole where the cursor is to figure out which is valid and what eventual types they will have.  Preferably without duplicating inference work.<br/><br/> * Purity, of course.<br/><br/>We don't think any existing type system combines these features, and we wanted the pedagogical experience, so we started implementing our own type system. We've rewritten it twice since, but we now understand there's much expertise gathered in the field that we could use.<br/><br/>If you're willing to lend a hand, advice or even implementation work, we'd love for you to contribute :-)
Share love about functional languages! Say bye to thousands of lines, nulls, undefines and more ... #fsharp #erlang #haskell #scala
Haskell is a wonderful language - it's functional, strongly typed, elegant, and lovely to code in. However, to many programmers (even seasoned ones), it's daunting to learn. As a Haskell programmer trying to spread the joy of Haskell to friends and coworkers, this is a real pain. However, I have used Learn You a Haskell For Great Good!, by Miran Lipovaca, for some time now to help get others into Haskell, and I'm thrilled that it's finally been published as a physical book by No Starch Press. First a caution: Learn You a Haskell is not designed for non-programmers - it is not a guide to learn how to program. Rather, it's a guide for programmers who are used to imperative languages (like C, Java, or even Fortran) to learn about functional languages (and, obviously, Haskell in particular). What's nice about this book compared to other typical programming guides is that it's engaging to read; it's funny and cute, and the content is consistently clear. Also, the order in which the material is presented makes sense. The book starts out with a few chapters on the basics. Lipovaca shows how to call functions, use lists and tuples, and understand the basic type system. He goes on to explain pattern matching, recursion, and higher order functions - the bread and butter of functional programming. The descriptions and examples (and even the doodles) are great. He goes through the toolkit of many commonly used functions (reverse, zip, map, fold, ...) and shows how to implement them from scratch. Chapters 6 though 10 focus on actually using Haskell to write real programs. Modules are covered briefly before a great section on type classes. These can often be confusing to new Haskell programmers as they are very different from classes in a language like Java, but Lipovaca provides plenty of examples and clear explanations to make the learning process smooth. Next, input and output is introduced. Nothing very complicated is addressed - it's limited to basic console and file I/O - but it's more than sufficient to give a pre-monad overview of I/O. Chapter 10 is almost like a halfway point in the book. We use what we've learned so far to make a nice, useful, functional program before delving into the deeper type classes that are so critical to advanced Haskell programming. The next few sections are where LYAH really shines. Where many Haskell resources introduce monads all at once with little reason for why they exist or how they were designed, Lipovaca builds into them beautifully. We start with a clear explanation of functors, then applicative functors, then monoids, and finally monads. It makes the following chapter on some common monads (Reader, Writer, and State) seem downright easy. (I'll admit: I had trouble with the State monad for a while when I was first learning Haskell - I wish I'd read this earlier!) The book ends with a chapter on zippers that seems oddly out of place. Where most of the other chapters build from their predecessors, this one had nothing to do with anything from the previous few chapters. I think it would have been much better suited just before or after chapter 10 than as the climax of the book. Overall, LYAH is a solid beginner's guide to Haskell. It covers most of the basics, does a great job with the beginning advanced material, and is fun to read to boot. I would have liked to see a section on Arrows, as I find myself using them more and more, but I recognize they're still pretty fringe right now, so I see this as only a minor fault. If you already feel comfortable with applicative functors and monads, this book won't provide much new material for you, but if you're anywhere from having no idea about Haskell to still afraid of the state monad, I highly recommend Learn You a Haskell For Great Good!.
Ericsson uses Erlang, which makes sense since they were they ones that pretty much developed it. The problem with Erlang is that it's functional "by mistake" rather than by design. It's generally not a very well designed language but it is very convenient. I have only seen Lua used as a config language (eg conky and awesome wm). Personally I would much rather use Python instead, I find Lua rather ugly. As far as functional languages go (Lua is not one of them), Scala get's a lot of attention, especially after companies like twitter decided to adopt it.<br/><br/>As far as Haskell go, [Google uses it](http://research.google.com/pubs/pub36970.html). As much as I love C++, immutability and pureness are required for scalable parallel code. And we need very good scalable code, because [the free lunch is not only over](http://www.gotw.ca/publications/concurrency-ddj.htm) but we have also run out of coffee at this point in time. Of course Haskell might end up not being the solution but it is a beautifully designed and strictly pure language.
I'd say, any project where you want something engineered to last, and to work correctly, is a great candidate for Haskell.  For one-off statistical tests and making charts for your slideshow, it may be harder to make the pitch that learning Haskell is worth it.  If you have a behavioral assay where you've been making your research scientists hand-score how many times a rat spins counterclockwise or something, do it in Haskell instead.  Or if a machine is streaming out fluorescence readings from a high-throughput assay of some kind and you want to data-mine, or to build lists of instructions for which plates to pass to the next processing stage: Haskell.<br/><br/>The sense I got from my year at Wyeth was that most lab-heads are interested in adopting new technology, but they don't think of themselves as technical people doing their own building.  My bosses, for example, wouldn't want to learn the scripting language for some new piece of equipment they would buy; but they _would_ choose a piece of equipment based on whether or not _I_ was interested in learning to script it - and I was just an intern.<br/><br/>If that attitude generalizes across Pharma companies, I think that this kind of characterization of Haskell would resonate with lab-head-level management: "Haskell is something that can slip into parts of your drug discovery process without damaging the parts that already work; and by choosing it will win you some really enthusiastic interns"<br/><br/>Wyeth loved it if they could develop a new assay and publish a paper about it.  There was real enthusiasm for doing whatever it took to build something interesting &amp; profitable, and they were very happy to hire people to do tech development.  If the person they hired said, "I really think that LabView is the future for this frog-egg-recording system I'm building," they'd buy him a bunch of LabView licenses (true story).<br/><br/>Speaking to Haskell's relationship with matlab - there are a handful of problems that I've had to solve once in matlab, and once in Haskell, so I can count as a small data point there.    <br/><br/>My Haskell solutions are an order of magnitude less buggy, and much quicker to write.  And I'm _happy_ when I'm writing them.  Debugging matlab is painfully slow.  I'm angry when I write Matlab code.  Many of the errors are silent - you never _really_ know when you're done debugging.  <br/><br/>The superiority of my Haskell implementations isn't just due to the fact that Haskell is usually the second-round implementation and I've already had practice with the problem. In a few rare cases, I solved the same problem three times: once in matlab, later in Haskell, and then later still a second time in matlab (because I really needed a working matlab version and I didn't like my first implementation). My second-round Haskell implementations beat my third-round Matlab implementations, too!<br/><br/>The pain-point of Haskell is that it might be hard to get people who are acquainted with matlab to make the investment to switch, if a Pharma company already has its office of "matlab gurus" established.  I don't believe it's actually hard to learn Haskell, but it can definitely _feel_ hard!  It's not the kind of mental exercise that Matlab people are used to doing.  For me, the motivation to learn came from falling in love with the syntax and the functional-purity philosophy, and from repeatedly running into the "complexity wall" with matlab and c.  Haskell is alien and I wonder if someone who isn't magnetically drawn to it from the beginning would stick with it long enough to reap the (guaranteed) benefits.<br/><br/>A few things don't work straight-out-of-the-box in haskell the way they do in matlab.   Plotting requires a little work instead of being a one-liner.  Image processing isn't a one-liner out of the box.  Matlab folks get really annoyed that you can't just start up Haskell, load an image with one command, and plot it with a second command.  Making a filter and doing some digital signal processing is pretty easy in Matlab (IF your data all fit in memory).<br/><br/>But of course there are some things that work out-of-the-box for Haskell and are very awkward in Matlab, too.  Not just language features but library stuff.  The Matlab Way encourages use of .mat binary files for storing data.  Essential things like reading and writing JSON data are hacked together by the community (mostly scientists... and we scientists are known to write pretty shoddy code).  Concurrency in Matlab is gross - in Haskell concurrency is a beautiful revelation :)  Streaming big files through a processing pipeline - wonderful in Haskell, not really a thing in Matlab (to my knowledge - maybe someone who does matlab big data would know better).  Even parsing CSV data in Matlab is broken because of the way it treats numeric and string data differently.<br/><br/>I don't know any R, and I haven't used BioHaskell (I don't do any molecular stuff), so I can't comment much on those.  But this message is probably too long anyway.
RT @Functionalworks: Love Functional Programming  and interested in #Fsharp, #Erlang and #Haskell give @theburningmonk a follow and it is h…
Love Functional Programming  and interested in #Fsharp, #Erlang and #Haskell give @theburningmonk a follow and it is his birthday! :)
Functional logic programming. It's like the love child of prolog and haskell
The one language I loved at university : Functional #Programming 101 - With #Haskell<br/> http://t.co/4scpF5wuZQ
Although he may have experience (as you say), at the same time he doesn't seem (*seem*! I don't talk about facts -- dunno what he's written) to have ever written or worked at...<br/><br/>* A larger project in a non-functional language or even OO language. Else he'd know about how bad side effects may be, e.g. in class constructors/destructors etc. There may be some pain coming with purely functional programming but it's less pain than writing OO code.<br/><br/>* A multi-threaded/concurrent project. Else he'd love how Erlang avoids inter-process side effects and wouldn't label side effects as the greatest invention since whatnot. Threads in conventional languages are just terrible.<br/><br/>I also don't see why he doesn't appreciate at all that a Haskell compiler finds most of the bugs before even running a program. All in all the article is neither logical nor actually worth reading. Sorry!
@functionaljobs hello! We help organise the FP events (Clojure, Haskell) in Melbourne, Aus, and would love to connect. :)
Configuring your Haskell environment - (tl) tony lawrence - My love of functional programming has been... http://t.co/68es7ynnrQ
@dFr2 Yah, the Syntax of Haskell is a bit nuts, coming from a C person like me. But I love the  purely functional nature of it. It’s fun.
@donsbot I would love to have you on to talk functional programming and Haskell. Would you possibly be interested?
I love functional programming, I really do, but FP purists can be so annoying.  No coincidence that Haskell and Hubris both start with H.
@daniel_collin I found Project Euler particularly efficient for getting into functional programming again. And Haskell is lovely.
Oh man do I love functional programming. I just wish I could use it on the job, but c'est la vie.<br/><br/>Writing a purely functional program gives me the warm fuzzies.
Haskell is one of the best languages out there when it comes to composing functions beautifully and elegantly. I highly recommend learning it if only to gain an appreciation of how great powerful type systems can be^1, and how much you can still do whilst constrained by functional purity.<br/><br/>[SML](http://smlnj-gforge.cs.uchicago.edu/) and OCaml make tradeoffs when it comes to theoretical elegance in exchange for performance. They are nice to learn because they take a slightly different approach to statically typed functional programming than Haskell. First class modules and functors are especially interesting. Unfortunately OCaml is not great at writing concurrent code - SML-NJ has [CML](http://cml.cs.uchicago.edu/) built in however^2<br/><br/>Scala is a nice language because it has a reasonable amount of industry penetration. It also offers great integration with other JVM languages, which is good if you have a large amount of Java code that you don't want to have to re-write. It extremely multiparadigm and makes heavy use of syntactic sugar which can be both a blessing and a curse because these lead to an extremely complex language that is difficult to learn. Like OCaml it also supports the Object-Oriented computational model, which is nice, but it also means you can lapse into old habits rather than being challenged to think differently.<br/><br/>Unlike the previous languages, Rust is aimed at lower-level systems programming. It makes serious concessions when it comes to composability and functional purity to ensure that programmers can write high performance code. This means that Rust code often tends to be more verbose and less elegant than Haskell code, but it is much more predictable when it comes to performance. Regions, lifetimes, explicit (but safe) memory management, type classes, message passing concurrency all make it a cutting edge systems language. It also offers a far better unsafe mode than the previously mentioned languages and far better support for integrating with C code.<br/><br/>In conclusion, each of these languages have their own strengths and weaknesses, and are all valuable in their own way. I would definitely recommend learning Rust if you want to learn more about systems programming and memory management. If you want elegance and beauty, have a go for either Haskell or SML. If you're interested in learning how to write concurrent code, go for either Rust or SML. OCaml is really nice because it has a lovely type system whilst remaining pragmatic. Scala is a challenging beast, but could be useful if you often work with the JVM.<br/><br/>---<br/><br/>1. That said, despite what many people think, Haskell doesn't have *the most* advanced/cutting edge type system out there. That credit goes to research languages like [Idris](http://idris-lang.org/). The difference is that these languages tend to be less polished than an older, more mature language like Haskell.<br/><br/>2. CML uses a concurrency model that is actually quite similar that which is found in Rust.
This is a talk I did for high school students at the National Computer Science summer school, held at Sydney University during our summer holiday. I was asked to come up with a topic and thought I'd spread the functional programming love with a brief introduction to the paradigm using Haskell for examples. I ended up teaching them lots of basic pure Haskell, but ran out of time to start on Monads (which was lucky, since I hadn't prepared slides for them!).<br/><br/>The bit at the end that just says 'tying it all together' was where I got out the whiteboard and drew up an evaluation of the lazy Fibonacci sequence definition at the start of the presentation. Due to time we had to skip all the slides on laziness as well, but they were a bright bunch and caught on regardless.<br/><br/>(The title was also a bit of a trick - I just needed something that sounded snappy and didn't involve a pun with the word _fun_, so I went for the next best thing.)<br/><br/>(Oh, and sorry for the page of links at the front. I gave the students the link to the doc, so if any of them come back to it I wanted them to see that information first.)
@abdullin I love Haskell, but like most functional languages, no take off,  no big enough community...the best is always the people you meet
@bestham twitter isn't giving me any context.. why do you love Haskell? Except for functional awesomeness? :)
I agree.  I think if one were to apply the lessons learned from functional programming to OS API design, one could come up with something pretty interesting.<br/><br/>I think the right approach is that, rather than just thinking about what FP features could be applied to an OS, think about what are the things that make modern operating systems painful to use, and can they be fixed?<br/><br/>For instance, modern OSes don't generally have any sort of undo feature.  If you delete a bit of text in a word processor, you can hit undo and everything's fine. If you move a bunch of files around and then realize you shouldn't have done that, you're out of luck unless you have a backup.<br/><br/>Modern SSDs don't re-write data in-place anyways, so it's kind of silly we don't use persistent data structures for the FS and keep a reference to the previous versions around.  (There are probably FSs out there that can do this, I haven't really looked into it, but it's not something you can take for granted on a modern system.)<br/><br/>Lack of undo also makes shell scripts hard to write.  Most of the time, you want a script to either succeed or, if it fails, you don't want to have any side effects.  Actually accomplishing this is hard and error-prone -- for every possible error, you have to be able to go back and manually undo everything you did.  Guaranteeing mutual exclusion is hard, too; any script or sysadmin task can race with any other, and that's considered normal.<br/><br/>I'd love to see some sort of STM-like system, where scripts run inside of atomic transactions and the filesystem is treated like any other shared datastructure.  If several transactions race, we just back out all the changes automatically, and re-run them sequentially.<br/><br/>There's a lot of cool things you could do by giving programs and files explicit types, known to the OS.  For instance, suppose you have a bunch of conversion tools for things like pdf, ps, dvi, etc..  Trying to run, say, ps2pdf on a dvi file could be caught by the shell as an error, instead of requiring the program to do all the input validation.  Or, let's say you have a dvi file you want to convert to ps, but don't remember what the command is called.  Maybe you could stick a wildcard in the command line, and the OS could select a program with the appropriate type conversion.<br/><br/>&gt;  cat foo.dvi | ??? &gt; foo.ps<br/><br/>could be automatically promoted to<br/><br/>&gt; cat foo.dvi | dvi2ps &gt; foo.ps<br/><br/>or even prompt you to install the appropriate utility, if it's not locally installed.<br/><br/>A truly paranoid OS might not even let you write out a file as a particular type unless the contents can pass a validation test.<br/>
After dabbling in several other programming languages I came across references to Haskell and quickly became interested in learning the language given (1) my disdain for over-sized and almost convoluted languages such as Java and C# and, (2) my background in Mathematics. Yes this is an interesting book that does an excellent job showing how well the abstraction of Mathematics can be quantified using Haskell yet, I do not believe that this book does any justice to those individuals the author claims the book is written for-"[t]his book does not assume the reader to have previous experience with either programming or construction of formal proof ...". Any inexperienced programmer or person with minimal Mathematical experience will, in no way, benefit from this book unless they have a quality teacher who can explain as well as expand on the material. In my humble opinion the person's who can utilize and benefit from this book are either semi-experienced functional programmers, young (possibly old) whiz-kids or the auto-didactic types who have the patience to refer to other sources for more explanation. As an example of the later claim, Exercise 1.11 asks the reader to "define a function called removeFst that removes the first occurrence of an integer m from a list of integers ..." without reference to working with/on lists. Further, this user defined function is expected to be used in the very next example (1.11) which, without assurance of the readers ability to define such a function, i.e. providing a solution, is pedagogically unsound. Either include a reference to the solution(s) on the authors website, include them in the book, or do a better job of NOT asking for chicken without providing the egg. This is not meant to be a negative review! Instead, it is a warning to those with minimal programming/Mathematics background expecting to learn Haskell. Personally, I loved this book and wish I came across it years ago. In fact, I wish I had come across functional programming years ago and therefore had not wasted years trying abstract other less abstract-able languages.
I got this book for a CS class in college but never used it (professors just love you to waste your money that way). I recently came back to this book after getting really into Python, especially the functional features. The approach the book takes is more or less instructing someone who knows absolutely nothing about programming in the ways of functional thinking. This makes it perfectly easy for an absolute beginner with no imperative or OOP prejudices to learn Haskell--just as if they were taught hex before decimal they'd catch onto hex real quick. This is also a great text for someone who's had some functional programming experience (map, filter, reduce, monads) and for whom recursion is a friend. I've become a much better Python programmer (and a better programmer in general) from just scanning the book every time in the bathroom. However, for a student who's been doing Java or C/C++ for a year or two, this will be extremely confusing. They will already have adopted a certain way of thinking and will have trouble going through this text. This is why this book was useless to me for several years. But for the advanced guys or the absolute n00bs I'd definitely recommend this book. As far as functional programming books go it's downright lively. My only complaint is that it doesn't really show me any practical things I can do with Haskell (these examples seem hard to find anywhere), such as database or GUI stuff. I mean sure it's cool to do a graph walk incredibly succinctly, but that's not something I'm going to use for work . . .
Ellie Simmons really wants to be thinner. But with her love of food, it wasn't going to happen any time soon. Then she gets an invitation to go see her family and is not sure what she should do. All she knows is that if she goes she must have a date. Ellie decides to hire an escort from an escort service but after meeting her date, Bently T. Haskell, she is about to regret it. They show up at Merlin's Court, only to have her cousin making eyes at Ben and her Uncle Merlin show up in odd places. An unexpected death and puzzle to solve is enough to put Ellie over the edge. She almost loses her appetite for food but Ben's cooking while they solve the puzzle helps her out. Can Ellie she trust anyone around her?My favorite character was Ellie. I could really relate to her struggles to lose weight and how society looked at her. She didn't let it get her down. Ellie had to persevere through everything in order to help solve the puzzle. She really had to work hard and make things work or she would not get an inheritance. Ellie was a true fighter and I loved how things worked out for her in the end. Now, now that she needed it but she really wanted it . My other favorite character was Dorcas. She was there to help solve the puzzle. She may have come towards the end of the book but her part was important. Dorcas filled in bits and pieces to things at the end that made everything seem right.The storyline and the characters of The Thin Woman were real to me. Ellie had to learn to change her habits towards food and embrace who she was becoming in order to earn her inheritance. The struggle that Ellie had with her family was interesting. I never knew families could be so dysfunctional. I could see that the struggle in this book had a purpose. It showed that life is a struggle but you need to keep going, the answer could be just around the corner.I really loved this book. Dorothy Cannell is a wonderful writer and she makes things so real to life. I had a difficult time putting it down. The twist and turns in the book were unpredictable and made the plot interesting. The surprise towards the end was worth the entire book. Cannell had me on the edge of my seat in one part and the next laughing my head off. This author is one amazing writer. I really enjoyed what she had written and I look forward to reading more books by her in the future. I recommend this book to anyone who loves a good mystery and not knowing who committed all the crimes.Reviewed by KristaFor BBW Reviews
Uuum, no, it’s still worse in functional programming languages. Because the original problem of having to walk through entire data structures is still there as you can’t have a graph data structure with loops. (As in: Pointers to directly access things deep inside structures. (See the problem of implementing a [hash] map.)<br/><br/>And your whole weird scenarios are complete nonsense that never happens in any game engine unless the coder somehow lost his mind halfway through.<br/><br/>You do not modify the source world tree EVER while in physics/AI routines! You “*clone*” the whole world tree, and *only* read from the one while you *only* modify to the other!  <br/>And you save most of that work with copy-on-write deduplication.<br/><br/>This was never a problem with any game engine. It isn’t so desperately needed, that it validates the horrible boilerplate mess of tree zippers.<br/><br/>And I love Haskell.
@Functionalworks I love this as an accidentally great into to Haskell: http://t.co/AY9cLcFOGR
This by far is one of the best programming books not only on Haskell as the language, but also the fundamentals of pure functional programming in general. This book in my opinion is a game changer to bring Haskell to the forefront of people's attentions. Whether you've been a programmer for years or just starting out, this book fits both needs quite nicely. If only other books could live up to this standard. With some proper emphasis on parallel programming, pure functional programming language shine. This section is very well written on patterns and strategies of parallel programming and multicore programming and some of the problems we face today. I highly recommend that people purchase this book. With the attention it has been receiving, I believe that it will dramatically increase the popularity and viability of pure functional programming. And best of all, I think you'll love it as I have.
&gt; Welcome to Hell!<br/><br/>I love it. I'll see if I can work up the courage to give it a try.<br/><br/>On a more serious note, this is going to need some libraries to make up for all the missing unix functionality (which you could technically use but wouldn't play nice with Haskell data types).
RT @Functionalworks: Check out why the guys @SQreamTech love #Haskell and how they have used it to create better quality software! http://t…
But lenses, just like any other such construct, is internally still massive tree-walking. It has to be, as long as it’s a functional language.<br/><br/>I mean the fact alone that you have to have this elaborate concept that actually has a name, to do something that essential, shows that something is very very wrong.<br/><br/>Ditto for monads.<br/><br/>And yes, I still love Haskell. And I want it to stay as great and elegant and all as it otherwise is. But this is something that needs to be fixed. Without any compromises whatsoever. (That the point.)
I do love #functional #interfaces and how #java is becoming more like #Haskell with version 1.8 - I made short-circuiting any & all.
@jherrm We've moved on to Haskell - I hear good things about the Yesod framework.  Kids love purely functional languages.
RT @BillLaboon: @jherrm We've moved on to Haskell - I hear good things about the Yesod framework.  Kids love purely functional languages.
Well if you compare Haskell with Common Lisp the latter does not seem very functional either. If you have an accurate definition of what constitutes a "functional programming language" I would love to hear it.